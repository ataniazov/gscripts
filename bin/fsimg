#!/usr/bin/env python2
import sys, os
import subprocess
import threading
import time
import getpass

# FIXME: detect /run or /dev
# TMP_FOLDER = "/run/shm/fsimg_%s" % os.getpid()
TMP_FOLDER = "/dev/shm/fsimg_%s" % os.getpid()
EXIT_FLAG=False
FLAG_ABNORMAL_EXIT=False
MOUNT_NO = 0

def create(filepath, size, fstype, pwd=None):
    if size[-1] in "kKmMgG":
        size_suffix = size[-1]
        size = int(size[:-1])
    else:
        size_suffix = ""
        size = int(size)

    if size_suffix == "":
        pass
    elif size_suffix in "kK":
        size <<= 10
    elif size_suffix in "mM":
        size <<= 20
    elif size_suffix in "gG":
        size <<= 30
    else:
        print "unknown size suffix"
        print "use K, M or G"
        exit(0)

    if os.path.exists(filepath):
        run("rm -f %s" % filepath) or exit(1)

    if pwd:
        run("randomgen %s > %s" % (size, filepath))
        run("cryptsetup --key-file=- luksFormat %s -c aes-xts-plain64 -s 512 -h sha512" % filepath,
            stdin_text=pwd)
        LUKS_NAME = generate_luks_name()
        run("cryptsetup --key-file=- luksOpen %s %s" % (filepath, LUKS_NAME), stdin_text=pwd)
        run("mkfs -t %s /dev/mapper/%s" % (fstype, LUKS_NAME))
        run("cryptsetup luksClose %s" % LUKS_NAME)
    else:
        run("truncate -s %s %s" % (size, filepath)) or exit(1)
        run("mkfs -t %s %s" % (fstype, filepath)) or exit(1)

    print "disk image create ok"

def mount(img, d, pwd=None, options="-o ro", name=None):

    isLUKS = False
    if img.startswith("/dev/"):
        out, _ = run("blkid %s" % img, out=True)
        if 'TYPE="crypto_LUKS"' in out:
            isLUKS = True
    else:
        out, _ = run("file %s" % img, out=True)
        if "LUKS encrypted file" in out:
            isLUKS = True

    if isLUKS:
        if name == None:
            LUKS_NAME = generate_luks_name()
        else:
            LUKS_NAME = name
        run("cryptsetup luksOpen %s %s" % (img, LUKS_NAME), stdin_text=pwd)
        img = "/dev/mapper/%s" % LUKS_NAME
    return run("mount %s %s %s" % (options, img, d))

def command_create():
    if len(sys.argv) != 5:
        print_usage_and_exit()
    _, _, filepath, size, fstype = sys.argv

    mount_options, fstype, encrypt, _name = get_mount_options(fstype)

    if filepath.startswith("/dev/") and not filepath.startswith("/dev/shm"):
        print "create file in /dev/ not supported"
        exit(1)

    PWD = None
    if encrypt:
        PWD = getPWD()
    create(filepath, size, fstype, pwd=PWD)

def getPWD():
    pwd1 = getpass.getpass()
    print "re-enter"
    pwd2 = getpass.getpass()
    while pwd1 != pwd2:
        print "pwd1 != pwd2\n"
        pwd1 = getpass.getpass()
        print "re-enter"
        pwd2 = getpass.getpass()
    return pwd1


def command_convert():
    if len(sys.argv) != 6:
        print_usage_and_exit()
    _, _, infile, outfile, outsize, outfstype  = sys.argv

    source = "%s/source" % TMP_FOLDER
    target = "%s/target" % TMP_FOLDER

    run("mkdir -p %s %s" % (source, target)) or exit(1)
    mount(infile, source) or exit(1)

    if outfile.startswith("/dev/"):
        print "outfile startswith /dev/"
        stdout, _ = run("blockdev --getsize64 %s" % outfile, out=True)
        outsize = "%s" % int(stdout)
        print "size changed to %s = sizeof(%s)" % (outsize, outfile)
        outfile_tmp = raw_input('write path for outfile_tmp:')
        print "tmpfile: %s" % outfile_tmp
    else:
        outfile_tmp="%s.tmp" % outfile

    mount_options, outfstype, encrypt, _name = get_mount_options("rw,"+outfstype)
    PWD = None
    if encrypt:
        PWD = getPWD()

    create(outfile_tmp, outsize, outfstype, pwd=PWD)
    mount(outfile_tmp, target, pwd=PWD, options=mount_options) or exit(1)

    print "copy files to new image"
    stop_flag=[False]
    if outfstype=="btrfs":
        show_du_df(target, stop_flag)
    run("cd %s; cp -a ./ %s" % (source, target)) or exit(1)
    stop_flag[0]=True

    print "umount tmp disk"
    run("umountlist %s | sh" % target) or exit(1)

    if outfile == infile:
        print "temporarily umounting source"
        source_umount_list, _ = run("umountlist %s" % source, out=True)
        run("umount %s" % source) or exit(1)

    if outfile.startswith("/dev/"):
        print "copy to device"
        run("dd if=%s of=%s oflag=direct bs=64K" % (outfile_tmp, outfile))
    else:
        run("mv %s %s" % (outfile_tmp, outfile))
    run("rm -f %s" % outfile_tmp)

    if outfile == infile:
        print "umounting source"
        run("%s" % source_umount_list)


def command_mount():
    if len(sys.argv) == 4:
        _, _, infile, target = sys.argv
        mount(infile, target) or exit(1)
    elif len(sys.argv) == 5:
        _, _, infile, target, fstype = sys.argv
        mount_options, fstype, encrypt, name = get_mount_options(fstype)
        mount(infile, target, options=mount_options, name=name) or exit(1)
    else:
        print_usage_and_exit()
    print "mount ok"

def main():
    global FLAG_ABNORMAL_EXIT
    try:
        os.umask(077)
        run("mkdir -p %s" % TMP_FOLDER)

        if len(sys.argv) < 2:
            print_usage_and_exit()
        command = sys.argv[1]

        if command == "create":
            command_create()
        elif command == "convert":
            command_convert()
        elif command == "convert2":
            command_convert2()
        elif command == "mount":
            command_mount()
        else:
            print_usage_and_exit()
    except SystemExit, e:
        if e.code != 0:
            FLAG_ABNORMAL_EXIT=True
    except:
        FLAG_ABNORMAL_EXIT=True
        import traceback
        print traceback.format_exc()
    finally:
        clean()


def run(cmd, out=False, stdin_text=None):
    if stdin_text:
        stdin = subprocess.PIPE
    else:
        stdin = None
    if out:
        p = subprocess.Popen(cmd, shell=True, stdin=stdin, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        return p.communicate(input=stdin_text)
        # return (r.stdout.read(), r.stderr.read())
    else:
        p = subprocess.Popen(cmd, shell=True, stdin=stdin)
        p.communicate(input=stdin_text)
        r = p.wait()
    if r:
        return 0
    return 1

def clean():
    global EXIT_FLAG
    EXIT_FLAG=True
    while run("umountlist %s" % TMP_FOLDER, out=True)[0] != "":
        print "waiting umount %s" % TMP_FOLDER
        run("umountlist %s | sh" % TMP_FOLDER, out=True)
    run("rm -rf %s" % TMP_FOLDER)
    run("stty echo")
    print "clean ok"
    if FLAG_ABNORMAL_EXIT:
        print "\nexited abnormally"
        exit(1)

def print_usage_and_exit():
    print "usage:   fsimg create imgpath size fstype"
    print "         fsimg convert infile outfile outsize outfstype"
    print "         fsimg mount infile target [fstype]"
    exit(1)

def show_du_df(x, stop=[True]):
    if EXIT_FLAG or stop[0]:
        return
    run("df -h %s" % x)
    run("btrfs filesystem df %s" % x)

    threading.Timer(5, lambda : show_du_df(x, stop)).start()

def generate_luks_name():
    global MOUNT_NO
    MOUNT_NO += 1
    return "fsimg_%s_%s" % (os.getpid(), MOUNT_NO)

def get_mount_options(outfstype):
    options = outfstype.split(",")

    if "enc" in options:
        encrypt = True
    else:
        encrypt = False

    mount_options = []
    if "btrfs" in options:
        mount_options += ["compress-force=zlib"]
        outfstype = "btrfs"
    elif "btrfs-lzo" in options:
        mount_options += ["compress=lzo"]
        outfstype = "btrfs"
    elif "ext2" in options:
        outfstype = "ext2"
    elif "ext4" in options:
        outfstype = "ext4"
    else:
        outfstype = None

    if "rw" in options:
        mount_options += ["rw"]
    if "ssd" in options:
        mount_options += ["ssd"]

    name = None
    for option in options:
        if option.startswith("name="):
            name = option[len("name="):]

    if len(mount_options):
        mount_options = "-o " + ",".join(mount_options)
    else:
        mount_options = "-o ro"
    return mount_options, outfstype, encrypt, name

def read_fs_type(f):
    out, _ = run("blkid %s" % f, out=True)
    t = [x.replace("TYPE=", "").replace("\"", "") for x in out.split() if x.startswith("TYPE=")]
    if len(t) != 1:
        print "!!! type error: "
        print out
        exit(1)
    return t[0]

if __name__ == '__main__':
    main()
